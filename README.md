# Certified Tech Dev - Proyecto Integrador

[[_TOC_]]

# HostingBook

HostingBook es una página web diseñada y adaptada para todos los dispositivos, la cual permite a los usuarios reservar alojamientos en diferentes ciudades, con diversas comodidades a disposición de los huéspedes y en la fecha que ellos elijan.

El objetivo al desarrollar dicha página no sólo implicó utilizar los conocimientos adquiridos durante el año, sino que también nos llevó a desafiarnos en llevar ideas propias a la práctica y poner en juego nuestras habilidades sociales.

Este proyecto es el resultado y el premio al trabajo en equipo, a las largas horas desvelados y al esfuerzo individual y grupal de cada uno de los integrantes que formamos parte de él.

# Equipo

## Valentina Varela Rodríguez

> Antes de ingresar al Certified Tech Developer estaba cursando el 3er cuatrimestre de Análisis de Sistemas en la FIUBA.
>
> En este proyecto trabajé sobre todo en la parte de frontend y backend aunque también realicé algunos testeos automatizados y manuales. Además de desarrollar nuevas features, me enfoqué en resolver bugs reportados.
>
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: |
> | Infraestructura | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Testing / QA | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |

## Kevin Sangregorio

> Previo a mi ingreso en Certified Tech Developer hice un cuatrimestre de la carrera de "Diseño y Programación Web" en la Escuela Da Vinci ubicada en C.A.B.A.  
>
> A lo largo del proyecto mi mayor incidencia fue en el área de frontend tanto en el desarrollo de features como en algunos aportes para mejorar la UX y/o la accesibilidad. Luego, realicé algunas features de backend y ciertas refactorizaciones tanto en dicha área como en base de datos para poder realizar el consumo de API's correcto desde el front. 
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Infraestructura | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Testing / QA | :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |

## Cintia Vettorazzi

> Al momento de iniciar "Certified Tech Developer" tenía algunos conocimientos previos en programación, adquiridos por cursar unos cuatrimestres en las carreras de "Desarrollo de Software" (IBP, Córdoba - Argentina) e "Ingeniería en Telecomunicaciones" en la Universidad Nacional de Río Cuarto (Córdoba - Argentina).
> 
> Durante los diferentes sprints a lo largo del proyecto "HostingBook" pude desempeñar varios roles, dependiendo de las necesidades del equipo y la organización en ese momento. Algunos de ellos fueron:
> * Desarrollo backend y frontend
> * Creación y análisis de base de datos
> * Testing manual y control QA 
> 
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Infraestructura | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Testing / QA | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |

## Sofía Tohmé

> Ingresar a Certified Tech Developer fue cambiar el rumbo de mi carrera 180°, ya que en ese momento me encontraba desempeñando mi profesión, ingeniería industrial, puntualmente en las áreas de logística y calidad y no contaba con conocimientos sobre programación.
>
> Al inicio del proyecto intenté ser parte activa ocupando diferente roles, pero dada la exigencia del proyecto, terminé trabajando mayormente en el área de frontend debido a que la velocidad del equipo aumentaba cuando cada integrante elegía y desarrollaba issues relacionadas con su mayor fortaleza. De todas maneras tuve participación en features de backend, en el mapeo de entidades con la base de datos y en los planes de ejecución de los test cases de cada sprint, así como también en el análisis de los datos que arrojaban para la posterior toma de decisiones.
>
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Infraestructura | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Testing / QA | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: :white_circle: |

## Miguel Espinosa

> Mi experiencia previa relacionada con la programación es completamente nula.
>
> Gracias a la metodología que abordamos en el grupo pude abordar parte de todas las áreas a desempeñar, sin embargo, tenía una responsabilidad principal, la cual tenía que ver con todo lo relacionado con Infraestructura y Mantenimiento de la misma.
>
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: :white_circle: |
> | Infraestructura | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: |
> | Testing / QA | :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |

## Hernán Serna

> Previo a ingresar al programa Certified Tech Developer, había terminado una especialización en evaluación de proyectos privados en la Universidad de Antioquia (Medellín-Colombia).
>
> Durante el proyecto, el mayor rol desempañado fue en el backend, aunque realicé algunas historias de usuario pequeñas que correspondían al frontend. En las tareas que colaboré fueron en la creación del diagrama entidad-relación en los primeros dos sprints, y algunas funcionalidades de seguridad y creación de APIs en el back. 
>
> | Tecnología | Fortaleza |
> |------------|-----------|
> | Frontend | :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: :white_circle: |
> | Backend | :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: :white_circle: |
> | Infraestructura | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Testing / QA | :large_blue_circle: :white_circle: :white_circle: :white_circle: :white_circle: |
> | Bases de datos | :large_blue_circle: :large_blue_circle: :large_blue_circle: :large_blue_circle: :white_circle: |

# Metodología de trabajo

Para desarrollar este proyecto utilizamos la metodología SCRUM. Lo que más nos gustó fue la posibilidad de autogestionarnos en base a lo que consideramos que tenemos mayores fortalezas, sumado al ambiente de trabajo, el cual nos permitió mantener una buena comunicación y tomar decisiones a tiempo.

Con respecto a los roles dentro del equipo, si bien inicialmente decidimos no dejar fijo ninguno, con el transcurso de las semanas fuimos descubriendo dónde cada une se sentía más cómode y fuimos respetando eso. Durante todos los sprints, cada une tomó las issues que prefería resolver y, al principio, decidimos desafiarnos a nosotres mismes tomando issues de áreas donde no nos sentíamos tan confiados. Esto nos sirvió para terminar de confirmar aquellas que creíamos que eran nuestras fortalezas y debilidades antes de comenzar el proyecto; y si alguna dificultad aparecía, nos valíamos del pair programming para sacar adelante aquellos puntos donde nos habíamos atascado.

# Bitácora del proyecto

## Sprint 1

El desafío más grande de este sprint fue la estimación de las tareas, subestimamos las issues y no supimos calcular cuánto tiempo nos iba a tomar resolver cada una, lo que hizo que lleguemos a la review con la aplicación prácticamente sin testear. Además, nos dimos cuenta que invertimos mal nuestros esfuerzos al juntarnos todes para hacer troubleshooting o resolver un problema puntual. Analizándolo en la retro nos dimos cuenta que nos convenía, por una cuestión de tiempos, intentar reducir la cantidad de integrantes en esos encuentros para que mientras tanto el resto pudiera seguir avanzando con sus issues.

## Sprint 2

En este segundo sprint, luego de la primera review, pudimos adoptar lo que mejor nos funcionó y dejar a un lado lo que no. Esto nos ayudó a mejorar el desempeño de cara a la segunda entrega. Arrancamos reorganizando las tareas de una manera distinta a la propuesta por los TLs, porque detectamos que se podía crear un cuello de botella con la planteada inicialmente. Esto nos sirvió para analizar mejor cada issue y poder estimar un poco mejor cuánto tiempo nos llevaría resolver cada una. Gracias a una mejor estimación, pudimos testear mucho más la aplicación y llegamos con más margen de tiempo a la review, aunque nos faltó ensayar la presentación y organizar backups en caso de presentarse alguna falla técnica. Esto generó que, debido a problemas de conectividad, nos excedimos del tiempo que teníamos para mostrar nuestro producto.

En cuanto a la parte técnica, lo que más nos costó resolver fue el backend de los productos, una tarea clave para avanzar con otras partes del proyecto. La dificultad radicaba en que `Producto` tenía muchas relaciones con otras entidades y resultó dificil encontrar el mapeo correcto para que todos los métodos funcionaran sin problemas. Sin embargo, la parte técnica no fue la única complicación: cuando detectamos los problemas teníamos muy poco tiempo para corregirlos.

Lo que tomamos como aprendizaje para el siguiente sprint fue ponerle deadlines a las tareas más importantes del mismo. Si en ese deadline no lográbamos resolverlo ni por nuestra cuenta ni con el equipo, concretar reuniones con los TLs para no atrasarnos y destrabar lo antes posible las tareas críticas.

## Sprint 3

En este ciclo notamos una mejora respecto a la entrega de valor y la organización en cuánto a los deadlines de las tareas. Sin embargo, notamos que se dedicó mucho tiempo al proyecto haciendo que haya pocas horas de descanso u ocio. Por otro lado, si bien fuimos más precavidos a la hora de la presentación y cada miembro del equipo tenía en su equipo local corriendo la aplicación por si la persona que presentaba tenía algún inconveniente, minutos previos a que nos tocara exponer tuvimos un contratiempo con la aplicación montada en AWS lo cuál complicó los tiempos de exposición nuevamente.

A partir de la identificación de estos problemas, decidimos darle mucha relevancia a los mismos en la Retro, proponiendo reorganizar nuestros tiempos con el fin de seguir entregando valor sin descuidar nuestra salud. Además, al saber que se aproximaba el último sprint acordamos con poner una fecha límite con respecto al desarrollo del mismo para poder dedicarle más tiempo a la presentación final y también, teniendo más planes alternativos para evitar cualquier imprevisto que pueda suceder en vivo.

## Sprint 4

De cara a este sprint, ya teníamos un poco más de comprensión de cuanto podrían tomarnos las issues que nos pedían y, si bien, era menor la cantidad de las mismas, quedaban muchas cosas por hacer, tales como issues pendientes del sprint anterior y un listado de mejoras que quisimos implementar. A pesar de ello, seguimos teniendo en cuenta lo relevante de nuestra salud (en términos de organización de tiempo para descansar y comer adecuadamente), ya que somos conscientes que ello puede bajar nuestro desempeño y estado anímico y creativo.

Si bien tuvimos algunos retrasos con funcionalidades de seguridad y problemas en el deploy con una configuración en la cual no se permitía cargar las url de endpoins solicitados (ya que por defecto Apache trata de buscar los html en carpetas, mientras que React trabaja con single pages), logramos superar esos inconvenientes el día anterior a la entrega, organizar el resto de los informes solicitados y la correspondiente presentación.

# Herramientas y tecnologías utilizadas

* **Herramientas para la gestión del proyecto**
  * GitLab boards
  * Discord
  * Google sheets
* **Herramientas para el desarrollo del proyecto**
  * IntelliJ
  * VSCode
  * MySQL Workbench
  * GitLab
  * MobaXTerm
* **Tecnologías utilizadas**
  * Frontend → [React](https://es.reactjs.org/)
  * Backend → [Java 11](https://www.oracle.com/java/technologies/downloads/#java11), [Maven](https://maven.apache.org/download.cgi) y [Spring Boot](https://spring.io/projects/spring-boot)
  * Base de datos → [MySQL](https://www.mysql.com/)
  * Infraestructura → [Amazon Web Services](https://aws.amazon.com/)
  * Testing → [JUnit](https://junit.org/junit5/), [Jest](https://jestjs.io/) y [Postman](https://www.postman.com/)

# Documentación técnica del proyecto

## Ambiente de desarrollo

1. Clonar el proyecto

   ```shell
    git clone https://gitlab.com/proyecto-integrador-0321/camada-3/grupo-4.git
   ```


2. Desde workbench
   1. Crear una nueva conexión:
      - Hostname: `localhost`
      - Port: `3306`
      - Username: `root`
      - Password: `root`
   2. Abrir y ejecutar el script `../db_scripts/script_develop.sql` que va a crear los schemas e insertar datos en la BD


3. Correr el backend con el perfil `develop`
   1. Desde la terminal pararse en la carpeta `/grupo-4/backend/HostingBook`
   2. Ejecutar el comando `mvn spring-boot:run -Dspring-boot.run.profiles=develop`


4. Correr el frontend
   1. Desde la terminal pararse en la carpeta `/grupo-4/frontend/digitalbooking`
   2. Ejecutar el comando `npm install`
   3. Ejecutar el comando `npm start`

## Acuerdos a la hora de desarrollar

Para mantener en la rama `main` versiones estables del proyecto decidimos trabajar con el siguiente workflow:

![Workflow gitlab]![image](https://user-images.githubusercontent.com/45428425/146567969-b207992e-21ab-4ed0-a01a-61d3cbe27e9b.png)

* Inicialmente pusheamos a `main` una configuración inicial para comenzar a trabajar
* Luego creamos la rama `develop`, sobre la cual trabajamos en todos los sprints
* Por cada issue a resolver creamos una nueva rama asociada a un merge request para mergear dicha rama a `develop`
* Cuando la issue esta lista pasa de _"En progreso"_ a _"Pendiente revisión"_ y se marca el MR como ready.
* En esta instancia otro integrante del equipo revisa el código. Si está todo bien el MR se aprueba, y la issue pasa al board _"Pendiente QA"_, si hay cosas para corregir o mejorar se comentan en el MR, se modifican y se vuelve a revisar.
* Una vez que el MR queda aprobado, se mergea la rama de la issue a `develop`
* Al finalizar el sprint, cuando todas las ramas de las issues ya están en `develop`, se ejecutan los tests de regresión y de humo. Si no hay ninguna falla crítica se mergea `develop` a `main`

## Base de datos

![DER Usuario]![image](https://user-images.githubusercontent.com/45428425/146568012-8bf2e8b6-488f-4123-bfdc-4515e0f27e76.png)

![DER Producto]![image](https://user-images.githubusercontent.com/45428425/146568048-a62c1fca-b34f-4cd6-bed8-4b378d268c94.png)

![DER Usuario con Producto]![image](https://user-images.githubusercontent.com/45428425/146568102-cb69b211-dcb5-42f3-b36d-9203d4b6e727.png)


## Backend

La documentación completa de la API se puede ver [acá](http://3.133.206.239:8080/swagger-ui/).

* Estructura del proyecto

  ![Estructura de paquetes]![image](https://user-images.githubusercontent.com/45428425/146568181-1588271c-131a-48c2-8f4c-012380671081.png)


* Entidades

  ![Entidades]![image](https://user-images.githubusercontent.com/45428425/146568207-d1f854fe-2cd1-43d0-92bc-1284af70dcb5.png)


* Repository

  ![Repository]![image](https://user-images.githubusercontent.com/45428425/146568233-1cde9a1f-394d-4e66-aadd-8b5ac7f9d4ef.png)


* Service

  ![Service]![image](https://user-images.githubusercontent.com/45428425/146568263-ed003e31-cc8c-444b-b455-8374c6c4a907.png)


* Controllers

  ![Controllers]![image](https://user-images.githubusercontent.com/45428425/146568295-8afc0ad0-7641-4b9b-9ab0-775ad4832ff0.png)


## Infraestructura

![image](https://user-images.githubusercontent.com/45428425/146568313-8c73f31b-45c7-427d-bee3-e497225a0222.png)


## Testing y calidad

En cuanto al testing de la página web, podemos decir que se llevaba a cabo a diariamente y de la forma más específica posible. Si bien sabemos que el testeo no tiene fin, se intentó probar la mayor cantidad de funcionalidades entregadas por parte de los integrantes del equipo y evitar el sesgo existente cuando los tester prueban funcionalidades desarrolladas por ellos mismos.

A partir del segundo sprint generamos una doble barrera de testeo:
* La primera, una revisión de caja blanca (dedicada únicamente a la parte de código).
* La segunda, un control de calidad (donde además del control, se iban reportando posibles mejoras y agregados que no hacían a la funcionalidad requerida en sí, pero sumaba en cuanto a accesibilidad y usabilidad).

Por otro lado, cabe aclarar que muchos test fueron hechos para propuestas sugeridas que luego no se concretaron y, sin embargo, quedaron planteados para una posible futura iteración. Estos test, que pueden verse por ejemplo en Postman, no fueron tomados en cuenta para calcular el pass rate de la app (por más que se encuentren en las colecciones presentadas en el informe final).

Con respecto al testeo de componentes del lado de front end decidimos implementar react testing library, ya que el mismo es lo suficientemente flexible para poder interactuar con todos los ámbitos delos componentes. Se agrupó dichos testeos en tres tipos de tests: 
*La renderización (la cual verificaba que el compontente adiquieriera ciertos componentes al llamarlo con datos previamente suministrados). Para verificar la renderización decidimos utilizar snapshots, los cualues imitan en otro documento el formato HTML que debería adquirir el componente para compararlos.
*La interacción con el usuario ( la cual examinaba distintos eventos del usuario para que el componente cambiara de alguna u otra manera). Para simular el comportamiento del usuario con el componente decidimos usar eventos simulados por la función "find" del renderizado 'mount' o "fireEvent" del renderizado  'render', posterior a ello llamábamos ala etiqueta que estimábamos que hubiese cambiado y lo comparábamos con dato esperado.
*La interacción con llamados a la API por medio de hooks creados por nosotros (que básicamente simulaba la API con una funcion en un documento JS que devolvía unos datos esperados apartir de ciertos parámetros).

Cabe destacar que muchos de los componentes utilizaban Hooks de react como 'useContext', 'useHistory' ,'useParams', etc. Los cuales tuvieron que ser mockeados con la funcionalidad 'jest.fn()'. Otra cosa a acotar es el hecho que se usaban contextos predefinidos con valores enviados al componente que se tuvieron que implementar en los test para poder recibir las respuestas esperadas. Cada uno de estos tipos de tests representa un caso de prueba. 
Así que, teniendo en cuenta la información esperada en un contexto ideal se podría esperar entre 1 y 3 casos de prueba por cada componente si se quisiese experimentar solo los 'caminos felices' o entre 4 y 6 casos de prueba si se quisese explorar casos de prueba negativos.

A través de los siguientes links presentamos las [tablas generales de testeo manual](https://docs.google.com/spreadsheets/d/1RrgfydWOFJYb82cFC6F8qcCgBWdM6ulboiBwaWzee7M/edit?usp=sharing)
, que incluyen:
* Casos de pruebas
* Defectos de documentación/Testing estático
* Defectos de ejecución
* Testing exploratorio
* Ciclos planteados por sprint y gráficos de defectos

Como así también el [informe del Reporte final de Testing](https://docs.google.com/document/d/1VAgIW3oCeY8JQk1bS8tAUZ3ouldcN-25Xf16FK9RCQ0/edit#) .

